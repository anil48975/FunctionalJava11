DataStucture and Algorithm::
	Archimedes had discovered an analysis tool (displacement).
	
	a data structure is a systematic way of organizing and accessing
	data, and an algorithm is a step-by-step procedure for performing some task in
	a finite amount of time.
	
	All other factors being equal, the running time of the same algorithm on the same input data will be
	smaller if the computer has, say, a much faster processor or if the implementation
	is done in a program compiled into native machine code instead of an interpreted
	implementation run on a virtual machine.
	
	Algorithm Amalysis:
	1. Experimental Studies
		One way to study the efficiency of an algorithm is to implement it and experiment
		by running the program on various test inputs while recording the time spent during
		each execution.
		
		long startTime = System.currentTimeMillis( ); // record the starting time
		2 /* (run the algorithm) */
		3 long endTime = System.currentTimeMillis( ); // record the ending time
		4 long elapsed = endTime - startTime; // compute the elapsed time
		
		Java provides a method, nanoTime, that measures in nanoseconds rather than milliseconds.
		
		We can then visualize the results by plotting the performance of each run of the algorithm as a point with x-coordinate
		equal to the input size, n, and y-coordinate equal to the running time, t.
		
		However, the measured times reported by both methods currentTimeMillis and
		nanoTime will vary greatly from machine to machine, and may likely vary from
		trial to trial, even on the same machine. This is because many processes share use
		of a computer’s central processing unit (or CPU) and memory system; therefore,
		the elapsed time will depend on what other processes are running on the computer
		when a test is performed.
		
		
		/** Uses repeated concatenation to compose a String with n copies of character c. */
		2 public static String repeat1(char c, int n) { 3 String answer = "";
		4 for (int j=0; j < n; j++)
		5 answer += c;
		6 return answer;
		7 } 8
		9 /** Uses StringBuilder to compose a String with n copies of character c. */
		10 public static String repeat2(char c, int n) { 11 StringBuilder sb = new StringBuilder( );
		12 for (int j=0; j < n; j++)
		13 sb.append(c);
		14 return sb.toString( );
		15 }
		
		n                        repeat1 (in ms)                                 repeat2 (in ms)
		12,800,000               265,696,421                                     135
		
		Challenges of Experimental Analysis:
		- difficult to directly compare unless the experiments are performed in the same environments.
		- can be done only on a limited set of test inputs
		- An algorithm must be fully implemented in order to execute
		
		Moving Beyond Experimental Analysis:
		To analyze the running time of an algorithm without performing experiments, we
		perform an analysis directly on a high-level description of the algorithm (either in
		the form of an actual code fragment, or language-independent pseudocode). We
		define a set of primitive operations such as the following:
		• Assigning a value to a variable
		• Following an object reference
		• Performing an arithmetic operation (for example, adding two numbers)
		• Comparing two numbers
		• Accessing a single element of an array by index
		• Calling a method
		• Returning from a method
		Formally, a primitive operation corresponds to a low-level instruction with an execution
		time that is constant.
		
		Seven Functions:
		constant function: that is, f (n) = c,
		The Logarithm Function: f (n) = logb n, for some constant b > 1.
		This function is defined as the inverse of a power, as follows:
					x = log n  base b if and only if b to the power x = n.
		Example: 	5 = log 32 base 2 if and omly if 2 to the power 5 = 32
		linear function:  f (n) = n.
		n-log-n function: f (n) = nlog n,
		quadratic function, f (n) = n2.
		cubic function: f (n) = n3,
		exponential function: f (n) = b to the power n,
		
		Asymptotic Analysis:
		We analyze algorithms using a mathematical notation for functions that disregards
		constant factors. Namely, we characterize the running times of algorithms
		by using functions that map the size of the input, n, to values that correspond to
		the main factor that determines the growth rate in terms of n.
		
		The "Big-Oh" Notation:
		Let f (n) and g(n) be functions mapping positive integers to positive real numbers.
		We say that f (n) is O(g(n)) if there is a real constant c > 0 and an integer constant
		n0 = 1 such that
		f (n) = c ·g(n), for n = n0.
		This definition is often referred to as the “big-Oh” notation, for it is sometimes pronounced
        as " f (n) is big-Oh of g(n)."
		
		Example 1: The function 8n+5 is O(n).
		Justification: By the big-Oh definition, we need to find a real constant c>0 and
		an integer constant n0 = 1 such that 8n+5 = cn for every integer n = n0. It is easy
		to see that a possible choice is c = 9 and n0 = 5. Indeed, this is one of infinitely
		many choices available because there is a trade-off between c and n0. For example,
		we could rely on constants c = 13 and n0 = 1.
		
		The big-Oh notation allows us to say that a function f (n) is "less than or equal
		to" another function g(n) up to a constant factor and in the asymptotic sense as n
		grows toward infinity.
		
		Example 2: 5ne4 +3ne3+2ne2 +4n+1 is O(n4).
		Justification: Note that 5ne4+3ne3+2ne2+4n+1= (5+3+2+4+1)ne4 = cne4,
        for c = 15, when n = n0 = 1
		
		Example 3:
		If f (n) is a polynomial of degree d, that is,
		f (n) = a0 +a1n+···+adned ,
        and ad > 0, then f (n) is O(ned).
		Justification: Note that, for n = 1, we have 1 = n = ne2 = ··· = ned; 
		hence,
		a0+a1n+a2ne2+···+adned = (|a0|+|a1|+|a2|+···+|ad|)ned.
        We show that f (n) is O(ned) by defining c = |a0|+|a1|+···+|ad| and n0 = 1.
		
		Example 4. 5ne2 +3nlog n+2n+5 is O(ne2).
		Justification: 5ne2+3nlog n+2n+5=(5+3+2+5)ne2 =cne2, for c=15, when
		n = n0 = 1.


______________________________________________________________________________________________

Base to the power exponent

Polynomial algorithm: An Algorithm where n is base, n to the power m
Exponential algorithm: An Algorithm where n is in power[exponent] of some base, m to the power n
		
		